<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>無題ドキュメント</title>
<meta name="viewport" content="width=320, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" href="./css/type.css">
<style>

</style>
</head>
<body>

<div id="typeApp">
  <div id="cardUI" ref="cardWrap">
    <!--template v-for="(d,i) in cardList" :key="d.id">
    <div class="card" :data-id="d.id" @touchstart.stop="onTouch">
      <div class="photo"><img :src="d.src" width="100%"></div>
      <div class="status">
        <dl>
          <dt>{{d.label}}-{{d.id}}</dt>
        </dl>
      </div>
    </div>
    </template-->
  </div>
  <div id="btnUI">
    <a href="#" class="btn skip" @click="onSkip"></a>
    <a href="#" class="btn type" @click="onType"></a>
  </div>
</div>

<script rel="preload" src="https://unpkg.com/vue/dist/vue.min.js" charset="utf-8" as="script"></script>
<script>
'use strict'
const returnApi = [
  {
    //id: '11284',
    src: './img/type/mio_1.jpg',
    label: '今田美桜1 19歳 東京都'
  },
  {
    //id: '9980',
    src: './img/type/mio_2.jpg',
    label: '今田美桜2 19歳 東京都'
  },
  {
    //id: '662',
    src: './img/type/mio_3.jpg',
    label: '今田美桜3 19歳 東京都'
  },
  {
    //id: '11130',
    src: './img/type/mio_1.jpg',
    label: '今田美桜4 19歳 東京都'
  },
  {
    //id: '23',
    src: './img/type/mio_2.jpg',
    label: '今田美桜5 19歳 東京都'
  },
  {
    //id: '9999',
    src: './img/type/mio_3.jpg',
    label: '今田美桜6 19歳 東京都'
  }
]
const returnApi2 = [
  {
    src: './img/type/mio_1.jpg',
    label: '今田美桜7 19歳 東京都'
  },
  {
    src: './img/type/mio_2.jpg',
    label: '今田美桜8 19歳 東京都'
  },
  {
    src: './img/type/mio_3.jpg',
    label: '今田美桜9 19歳 東京都'
  },
  {
    src: './img/type/mio_1.jpg',
    label: '今田美桜10 19歳 東京都'
  },
  {
    src: './img/type/mio_2.jpg',
    label: '今田美桜11 19歳 東京都'
  },
  {
    src: './img/type/mio_3.jpg',
    label: '今田美桜12 19歳 東京都'
  }
]
const CardStyle = class {
  constructor(vm) {
    this.vm = vm
    this.clientWidth = Math.ceil(vm.clientData.width)
    this.clientTop = Math.ceil(vm.clientData.top)
    this.clientLeft = Math.ceil(vm.clientData.left)
    this.maxDeg = 15
    this.nextScale = 0.8
    this.reminingScale = 0.2
    this.preMaxScale = 0.95
    this.type = ''
    this.state = {}
    this.nextCard = ''
  }
  set setNextCard(el) {
    this.nextCard = el
  }
  set setType(c) {
    if (c === 1) {
      this.type = true
    } else if (c === -1) {
      this.type = false
    }
  }
  set setTouchState(obj) {
    const pageXOffset = window.pageXOffset
    const pageYOffset = window.pageYOffset
    const rect = obj.clientRect
    const relativePositionX = rect.left + pageXOffset
    const relativePositionY = rect.top + pageYOffset
    const halfWidth = Math.floor(rect.width / 2)
    this.assign({
      'relativePositionX': relativePositionX,
      'relativePositionY': relativePositionY,
      'halfWidth': halfWidth,
      'quarterWidth': halfWidth / 2,
      'relativeTouchstartX': obj.startX - relativePositionX,
      'relativeTouchstartY': obj.startY - relativePositionY
    })
  }
  set setRelativeMoveX(v) {
    const val = v - this.state.relativePositionX - this.state.relativeTouchstartX
    this.setType = Math.sign(val)
    this.assign({
      'relativeMoveX': val,
      'movingDistance': Math.abs(~~(val))
    })
  }
  set setRelativeMoveY(v) {
    const val = v - this.state.relativePositionY - this.state.relativeTouchstartY
    this.assign({
      'relativeMoveY': val
    })
  }
  swipeScale() {
    const state = this.state
    const calScale = this.nextScale + ( this.reminingScale * ( state.movingDistance / state.halfWidth ) )
    const setScale = calScale < this.preMaxScale ? calScale : this.preMaxScale
    this.scale(setScale)
  }
  assign(obj) {
    const assignArray = Object.assign(this.state,obj)
    this.state = assignArray
  }
  swipe(el) {
    const state = this.state
    const deg = this.maxDeg * (state.movingDistance / state.halfWidth)
    const setDeg = this.type ? -deg : deg
    const addClass = this.type ? 'type' : 'nottype'
    const rmClass = this.type ? 'nottype' : 'type'
    el.style.transform = `translate3d(${state.relativeMoveX}px, ${state.relativeMoveY}px, 0) rotate(${setDeg}deg)`
    el.classList.add(addClass)
    el.classList.remove(rmClass)
  }
  scale(scale) {
    const nextCard = this.nextCard
    nextCard.style.transform = `scale(${scale})`
  }
}

const CardItem = Vue.extend({
  template: `
    <div class="card" :class="[setOrder,addClass]" :data-id="generateObj.id" @touchstart.stop="onTouch" @touchmove.stop="onSwipe" @touchend.stop="onEnd" :style="transForm" v-if="!released">
      <div class="photo"><img :src="generateObj.src" width="100%"></div>
      <div class="status">
        <dl>
          <dt>{{generateObj.label}}-{{generateObj.id}}</dt>
        </dl>
      </div>
    </div>
  `,
  data() {
    return {
      generateObj: {
        id: Math.floor( Math.random() * 10000 ),
        //id: '',
        src: '',
        label: '',
      },
      current: false,
      next: false,
      type: '',
      clientData: {
        width: '',
        left: '',
        top: '',
        halfWidth: '',
        quarterWidth: ''
      },
      setTransform: {
        transition: '',
        translateX: '',
        translateY: '',
        rotate: 0,
        scale: 1.0,
        opacity: ''
      },
      cardModel: {
        transitionDuration: .2,
        maxDeg: 15,
        nextScale: 0.8,
        reminingScale: 0.2,
        preMaxScale: 0.95,
        relativeStartX: '',
        relativeStartY: '',
        movingDistance: '',
        relativeMoveX: '',
        relativeMoveY: '',
        fallDistanceX: 80,
        fallDistanceY: 80,
      },
      released: false
    }
  },
  computed: {
    setOrder() {
      return {
        'current': this.current,
        'next': this.next
      }
    },
    addClass() {
      return {
        'type': this.type === 1 ,
        'nottype': this.type === -1
      }
    },
    transForm() {
      const s = this.setTransform
      return {
        transitionDuration: `${s.transition}s`,
        transform:`translate3d(${s.translateX}px,${s.translateY}px,0) rotate(${s.rotate}deg) scale(${s.scale})`,
        opacity: s.opacity
      }
    }
  },
  mounted() {
    this.$nextTick(function(){
      this.setInstance()
      this.setClientData()
      //this.Card = new CardStyle(this)
      console.log('mount')
      console.log(typeApp.cardInstance)
    })
  },
  methods: {
    setClientData() {
      const clientRect = this.$el.getBoundingClientRect()
      this.clientData.width = clientRect.width
      this.clientData.left = clientRect.left
      this.clientData.top = clientRect.top
      this.clientData.halfWidth = clientRect.width / 2
      this.clientData.quarterWidth = clientRect.width / 4
    },
    setInstance() {
      //const obj = {}
      /*
      obj[this.generateObj.id] = this
      Object.assign(typeApp.cardInstance,obj)
      */
      typeApp.cardInstance.splice(0,0,this)
    },
    onTouch(e) {
      const Card = this.cardModel
      const cliendData = this.clientData
      const startX = e.changedTouches[0].pageX
      const startY = e.changedTouches[0].pageY

      Card.relativeStartX = (startX - cliendData.left)
      Card.relativeStartY = (startY - cliendData.top)
    },
    onSwipe(e) {
      const Card = this.cardModel
      const cliendData = this.clientData
      const transform = this.setTransform
      const moveX = e.changedTouches[0].pageX
      const moveY = e.changedTouches[0].pageY

      Card.relativeMoveX = (moveX - cliendData.left - Card.relativeStartX)
      Card.relativeMoveY = (moveY - cliendData.top - Card.relativeStartY)
      this.type = Math.sign(Card.relativeMoveX)
      Card.movingDistance = Math.abs(~~(Card.relativeMoveX))

      const deg = Card.maxDeg * (Card.movingDistance / cliendData.halfWidth)
      const setDeg = (this.type === 1 ? -deg : deg)

      transform.translateX = Card.relativeMoveX
      transform.translateY = Card.relativeMoveY
      transform.rotate = setDeg

    },
    onEnd(e) {
      const Card = this.cardModel
      const cliendData = this.clientData
      const transform = this.setTransform

      transform.transition = Card.transitionDuration
      const setTimeoutDuration = transform.transition * 1000
      if (Card.movingDistance > cliendData.quarterWidth) {
        const releaseMoveX = transform.translateX + (this.type === 1 ? Card.fallDistanceX : -Card.fallDistanceX)
        const releaseMoveY = transform.translateY + Card.fallDistanceY
        transform.translateX = releaseMoveX
        transform.translateY = releaseMoveY
        transform.opacity = 0
        setTimeout(function(){
          this.onRelease()
        }.bind(this),setTimeoutDuration)
      } else {
        transform.translateX = 0
        transform.translateY = 0
        transform.rotate = 0
        setTimeout(function(){
          this.type = 0
          transform.transition = 0
        }.bind(this),setTimeoutDuration)
        
      }
    },
    onRelease() {
      vueBus.$emit('onRelease',this.generateObj.id)
    }
  }
})

const vueBus = new Vue()
const typeApp = new Vue({
  el: '#typeApp',
  data: {
    loadedCardData: '',
    currentId: '',
    nextId: '',
    cardInstance: [],
  },
  created() {
    this.loadedCardData = returnApi
    vueBus.$on('onRelease',this.onRelease)
  },
  computed: {
    cardList() {
      return this.loadedCardData
    },
    cardWrap() {
      return this.$refs.cardWrap
    }
  },
  mounted(){
    this.setCardList(this.cardList,'mount')
    this.$nextTick(function(){
    })
  },
  methods: {
    setCardList(data,lifeCycle) {
      const vm = this
      const cardWrap = vm.cardWrap
      const isMount = (lifeCycle == 'mount')
      data.forEach(function(d,i){
        let cardItem = new CardItem()
        //cardItem.generateObj.id = d.id
        cardItem.generateObj.src = d.src
        cardItem.generateObj.label = d.label
        if (isMount) {
          if (i === 0) {
            cardItem.current = true
            vm.currentId = cardItem.generateObj.id
          } else if (i === 1) {
            cardItem.next = true
            vm.nextId = cardItem.generateObj.id
          }
        }
        cardItem.$mount()
        cardWrap.insertBefore(cardItem.$el,cardWrap.firstChild);
      })
    },
    onRelease(id) {
      const cardInstance = this.cardInstance
      cardInstance.forEach(function(item, i){
        if (item.generateObj.id === id) {
          //console.log(item)
          //console.log(i)
          item.released = true
          //item.$destroy()
          cardInstance.splice(i,1)
        }
      })
      if (cardInstance.length < 3) {
        this.setCardList(returnApi2)
      }
    },
    onType() {
      //const card = this.cardInstance[this.currentId]
    },
    onSkip() {

    }
  }
})
</script>
</body>
</html>
